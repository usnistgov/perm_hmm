import torch
from perm_hmm.classifiers.interrupted import IIDBinaryIntClassifier, IIDInterruptedClassifier
# from perm_hmm.postprocessing.interrupted_postprocessors import InterruptedEmpiricalPostprocessor, InterruptedExactPostprocessor
from perm_hmm.postprocessing import ExactPostprocessor, EmpiricalPostprocessor


def exact_train_ic(ic: IIDInterruptedClassifier, testing_states, all_data, log_joint,
                   num_ratios=20):
    """
    Train the interrupted classifier using the exact chances of the data occurring.

    The interrupted classifier takes as input a single parameter, the threshold likelihood ratio
    at which to terminate the run and conclude a classification.
    :param bayes_perm_hmm.interrupted.InterruptedClassifier ic: To be trained.
    :param torch.Tensor all_data: all possible runs of data.
    :param torch.Tensor log_probs: Corresponding log likelihoods of the data.
    :param torch.Tensor log_post_dist: Posterior log initial state distributions for all the runs. Last dimension is the state label.
    :param log_prior_dist: True log initial state distribution.
    :param num_ratios: number of points to perform the brute force search on.
    :return: A tuple containing the minimum misclassification rate over the searched domain and the corresponding threshold log ratio.
    """
    spaced_ratios = torch.arange(num_ratios, dtype=torch.float)
    misclass_rates = torch.zeros(num_ratios, dtype=torch.float)
    for j in range(num_ratios):
        ic.ratio = spaced_ratios[j]
        interrupted_results = ic.classify(
            all_data,
            testing_states,
        )
        iep = ExactPostprocessor(
            log_joint,
            testing_states,
            interrupted_results,
        )
        misclass_rates[j] = iep.log_misclassification_rate()
    min_rate = misclass_rates.min(-1)
    ic.ratio = spaced_ratios[min_rate.indices]
    return min_rate.values


def train_ic(ic: IIDInterruptedClassifier, testing_states, training_data, ground_truth, num_ratios=20):
    """
    :param bayes_perm_hmm.interrupted.InterruptedClassifier ic: the InterruptedClassifier to train.
    :param training_data: data to train on
    :param ground_truth: The true initial states which generated the data.
    :param num_ratios: The number of points to perform the brute force search on.
    :return: A tuple containing the minimum average misclassification rate and its corresponding threshold log ratio.
    """
    spaced_ratios = torch.arange(num_ratios, dtype=torch.float)
    misclass_rates = torch.zeros(num_ratios, dtype=torch.float)
    for j in range(num_ratios):
        ic.ratio = spaced_ratios[j]
        interrupted_results = ic.classify(
            training_data,
            testing_states,
        )
        iep = EmpiricalPostprocessor(
            ground_truth,
            testing_states,
            interrupted_results,
        )
        rates = iep.misclassification_rates()
        misclass_rates[j] = rates.average.rate
    min_rate = misclass_rates.min(-1)
    ic.ratio = spaced_ratios[min_rate.indices]
    return min_rate.values

def train_binary_ic(bin_ic: IIDBinaryIntClassifier, training_data, actually_bright, num_ratios=20):
    """
    Trains the classifier. This is to find the optimal likelihood ratio
    thresholds to minimize classification error.

    :param torch.Tensor training_data: float.
        Data to train the classifier on.

        shape (num_samples, time_dim)

    :param torch.Tensor actually_bright: bool.
        Mask which indicates which runs were generated by the bright state.

        shape (num_samples,)

    :param int num_ratios: sets the grid size to perform the brute force
        search for the minimal misclassification rate on.

    :raises ValueError: if the classifier is not calibrated.
    """
    try:
        num_samples, max_t = training_data.shape
    except ValueError as e:
        raise ValueError(
            "Training data must have shape (num_samples, max_t)") from e
    ratios = torch.arange(num_ratios, dtype=torch.float)
    rates = torch.empty((num_ratios, num_ratios), dtype=torch.float)
    ground_truth = actually_bright.int()
    for i in range(len(ratios)):
        for j in range(len(ratios)):
            bin_ic.bright_ratio = ratios[i]
            bin_ic.dark_ratio = ratios[j]
            interrupted_results = bin_ic.classify(training_data, torch.arange(2), verbosity=0).int()
            iep = EmpiricalPostprocessor(
                ground_truth,
                torch.arange(2),
                interrupted_results,
            )
            rates_and_intervals = iep.misclassification_rates()
            rates[i, j] = rates_and_intervals.average.rate
    ind = divmod(rates.argmin().item(), rates.shape[1])
    bin_ic.bright_ratio = ind[0]
    bin_ic.dark_ratio = ind[1]

def exact_train_binary_ic(bin_ic: IIDBinaryIntClassifier, all_data, testing_states, log_joint, num_ratios=20):
    """
    Trains the classifier. This is to find the optimal likelihood ratio
    thresholds to minimize classification error.

    :param torch.Tensor training_data: float.
        Data to train the classifier on.

        shape (num_samples, time_dim)

    :param torch.Tensor actually_bright: bool.
        Mask which indicates which runs were generated by the bright state.

        shape (num_samples,)

    :param int num_ratios: sets the grid size to perform the brute force
        search for the minimal misclassification rate on.

    :raises ValueError: if the classifier is not calibrated.
    """
    ratios = torch.arange(num_ratios, dtype=torch.float)
    rates = torch.empty((num_ratios, num_ratios), dtype=torch.float)
    for i in range(len(ratios)):
        for j in range(len(ratios)):
            bin_ic.bright_ratio = ratios[i]
            bin_ic.dark_ratio = ratios[j]
            interrupted_results = bin_ic.classify(
                all_data,
                testing_states,
            ).int()
            iep = ExactPostprocessor(
                log_joint,
                testing_states,
                interrupted_results,
            )
            rates[i, j] = iep.log_misclassification_rate()
    ind = divmod(rates.argmin().item(), rates.shape[1])
    bin_ic.bright_ratio = ind[0]
    bin_ic.dark_ratio = ind[1]
